// Stateless HMAC-signed message share links
// URL format: /m/[messageId]?e=[expiryTimestamp]&s=[signature]
// No database changes needed â€” signature proves the link was generated by the server

const SHARE_SECRET = process.env.MESSAGE_SHARE_SECRET || process.env.SUPABASE_SERVICE_ROLE_KEY || 'wrr-msg-share-fallback'
const DEFAULT_EXPIRY_DAYS = 7

async function hmacSign(data: string): Promise<string> {
  const key = await crypto.subtle.importKey(
    'raw',
    new TextEncoder().encode(SHARE_SECRET),
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign']
  )
  const sig = await crypto.subtle.sign('HMAC', key, new TextEncoder().encode(data))
  // URL-safe base64
  return btoa(String.fromCharCode(...new Uint8Array(sig)))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/, '')
}

export async function generateMessageShareURL(
  messageId: string,
  baseUrl: string,
  expiryDays: number = DEFAULT_EXPIRY_DAYS
): Promise<string> {
  const expires = Math.floor(Date.now() / 1000) + (expiryDays * 86400)
  const payload = `${messageId}:${expires}`
  const sig = await hmacSign(payload)
  return `${baseUrl}/m/${messageId}?e=${expires}&s=${sig}`
}

export async function verifyMessageShareToken(
  messageId: string,
  expiryStr: string | null,
  signature: string | null
): Promise<{ valid: boolean; error?: string }> {
  if (!expiryStr || !signature) {
    return { valid: false, error: 'Missing token parameters' }
  }

  const expires = parseInt(expiryStr, 10)
  if (isNaN(expires)) {
    return { valid: false, error: 'Invalid expiry' }
  }

  // Check expiry
  const now = Math.floor(Date.now() / 1000)
  if (now > expires) {
    return { valid: false, error: 'This share link has expired' }
  }

  // Verify signature
  const payload = `${messageId}:${expires}`
  const expectedSig = await hmacSign(payload)

  if (signature !== expectedSig) {
    return { valid: false, error: 'Invalid share link' }
  }

  return { valid: true }
}
